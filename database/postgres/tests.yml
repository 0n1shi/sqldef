CreateTable:
  compare_with_generic_parser: true
  sql: |
    CREATE TABLE bigdata (
      id bigint,
      created_at timestamp with time zone,
      created_date time with time zone,
      fn integer default foo.my_func()
    );
CreateTableWithConstrant:
  sql: |
    CREATE TABLE tbl (
      id bigint,
      user_id bigint,
      email text,
      PRIMARY KEY (id),
      CONSTRAINT uniq_email UNIQUE (email),
      CONSTRAINT user_id_fk FOREIGN KEY (user_id) REFERENCES users(id, name)
    );
CreateTableWithConstrantInlineColumn:
  compare_with_generic_parser: true
  sql: |
    CREATE TABLE tbl (
      id bigint PRIMARY KEY,
      user_id bigint REFERENCES users(id, name),
      email text UNIQUE
    );
CreateTableWithDefault:
  compare_with_generic_parser: true
  sql: |
    CREATE TABLE users (
      default_null integer default null,
      default_int integer default 20,
      default_bool bool default true,
      default_numeric numeric(5, 0) default 42.195,
      default_fixed_char character(3) default 'JPN'::bpchar,
      default_json json default '[]',
      default_json_with_cast json default '[]'::json,
      default_jsonb jsonb default '[]'::jsonb,
      default_current_timestamp timestamp default CURRENT_TIMESTAMP,
      default_current_date date default CURRENT_DATE,
      default_current_time time default CURRENT_TIME,
      default_array_int integer[] default '{}'::integer[],
      joined_at timestamp with time zone NOT NULL DEFAULT '0001-01-01 00:00:00'::timestamp without time zone
    );
CreateTableWithDefaultWithoutCompare:
  # Queries that cannot be parsed with generic parse OR results do not match
  sql: |
    CREATE TABLE users (
      default_int int default true,
      default_bool boolean default true,
      default_text text default '',
      default_now timestamp default now(),
      default_text_with_cast text default ''::text,
      default_array_constructor int[] DEFAULT ARRAY[],
      default_array_constructor_with_cast int[] DEFAULT ARRAY[]::int[]
    );
CreateTableWithSchema:
  compare_with_generic_parser: true
  sql: |
    CREATE TABLE public.bigdata (
      data bigint
    );
CreateTableWithNotNull:
  compare_with_generic_parser: true
  sql: |
    CREATE TABLE public.airline_confirmation (
      airline_id bigint,
      code varchar(512),
      booking_id bigint NOT NULL
    );
CreateView:
  compare_with_generic_parser: true
  sql: |
    create view hoge_view as
    select amount from hoge;
CreateViewWithCast:
  compare_with_generic_parser: true
  sql: |
    create view hoge_view as
    select amount::numeric(10,2) from hoge;
CreateViewWithFullColumn:
  sql: |
    CREATE VIEW public.hoge_view
    AS SELECT (hoge.amount)::numeric(10,2) AS amount_num FROM hoge;
CreateViewWithCaseWhen:
  sql: |
    create view hoge_view as
    select
      -- pattern 1
      amount::numeric(10,2) as amount_num1,
      -- pattern 2
      (
        jsonb_extract_path_text(payload, 'amount')
      )::numeric(10,2) as amount_num2,
      -- pattern 3
      (
        case hoge_type
          when 'hoge' then jsonb_extract_path_text(payload, 'hoge', 'amount')
        end
      )::numeric(10,2) as amount_num3,
      -- pattern 4
      (
        to_timestamp(
          jsonb_extract_path_text(payload, 'created')::bigint
        )
      ) as created,
      -- pattern 5
      (
        cast(
          to_timestamp(
            jsonb_extract_path_text(payload, 'created')::bigint
          ) as date
        )
      ) as created_date
    from hoge;
CreateViewWithoutFrom:
  sql: |
    create view v as select 10 as n;
CreateViewWithStarExpr:
  compare_with_generic_parser: true
  sql: |
    create view hoge_view as
    select t.* from hoge t;
CreateIndex:
  compare_with_generic_parser: true
  sql: |
    CREATE INDEX username on users using btree (name asc);
CreateIndexWithFuncCall:
  sql: |
    CREATE UNIQUE INDEX airline_confirmation_code_unique_idx
    ON public.airline_confirmation
    USING btree (airline_id, booking_id, lower((code)::text))
    WHERE ((code IS NOT NULL) AND (airline_id IS NOT NULL));
CreateIndexConcurrently:
  sql: |
    CREATE INDEX CONCURRENTLY username on users (name);
AlterTableUnique:
  compare_with_generic_parser: true
  sql: |
    ALTER TABLE users ADD CONSTRAINT username UNIQUE (name, age);
AlterTableAddForeignKey:
  compare_with_generic_parser: true
  sql: |
    ALTER TABLE ONLY public.posts ADD CONSTRAINT posts_ibfk_1 FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL ON UPDATE RESTRICT;
